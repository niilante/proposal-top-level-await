<!doctype html>
<head><meta charset="utf-8">
<title>Top-Level Await</title><script type="application/json" id="menu-search-biblio">[{"type":"clause","id":"introduction","aoid":null,"title":"Introduction","titleHTML":"Introduction","number":"","namespace":"https://mylesborins.github.io/proposal-top-level-await/","location":"","referencingIds":[],"key":"Introduction"},{"type":"op","aoid":"AsyncBlockStart","refId":"sec-asyncblockstart","location":"","referencingIds":[],"key":"AsyncBlockStart"},{"type":"clause","id":"sec-asyncblockstart","aoid":"AsyncBlockStart","title":"AsyncBlockStart ( promiseCapability, asyncBody, asyncContext )","titleHTML":"<ins>AsyncBlockStart ( <var>promiseCapability</var>, <var>asyncBody</var>, <var>asyncContext</var> )</ins>","number":"1","namespace":"https://mylesborins.github.io/proposal-top-level-await/","location":"","referencingIds":["_ref_8","_ref_10"],"key":"AsyncBlockStart ( promiseCapability, asyncBody, asyncContext )"},{"type":"op","aoid":"InnerModuleEvaluation","refId":"sec-innermoduleevaluation","location":"","referencingIds":[],"key":"InnerModuleEvaluation"},{"type":"clause","id":"sec-innermoduleevaluation","aoid":"InnerModuleEvaluation","title":"InnerModuleEvaluation( module, stack, index )","titleHTML":"InnerModuleEvaluation( <var>module</var>, <var>stack</var>, <var>index</var> )","number":"2","namespace":"https://mylesborins.github.io/proposal-top-level-await/","location":"","referencingIds":["_ref_4","_ref_6"],"key":"InnerModuleEvaluation( module, stack, index )"},{"type":"op","aoid":"ModuleExecution","refId":"sec-moduleexecution","location":"","referencingIds":[],"key":"ModuleExecution"},{"type":"clause","id":"sec-moduleexecution","aoid":"ModuleExecution","title":"ModuleExecution( module )","titleHTML":"ModuleExecution( <var>module</var> )","number":"3","namespace":"https://mylesborins.github.io/proposal-top-level-await/","location":"","referencingIds":["_ref_5"],"key":"ModuleExecution( module )"},{"type":"op","aoid":"AsyncFunctionStart","refId":"sec-async-functions-abstract-operations-async-function-start","location":"","referencingIds":[],"key":"AsyncFunctionStart"},{"type":"clause","id":"sec-async-functions-abstract-operations-async-function-start","aoid":"AsyncFunctionStart","title":"AsyncFunctionStart ( promiseCapability, asyncFunctionBody )","titleHTML":"AsyncFunctionStart ( <var>promiseCapability</var>, <var>asyncFunctionBody</var> )","number":"4","namespace":"https://mylesborins.github.io/proposal-top-level-await/","location":"","referencingIds":[],"key":"AsyncFunctionStart ( promiseCapability, asyncFunctionBody )"}]</script></head><body><div id="menu-toggle">☰</div><div id="menu-spacer"></div><div id="menu"><div id="menu-search"><input type="text" id="menu-search-box" placeholder="Search..."><div id="menu-search-results" class="inactive"></div></div><div id="menu-pins"><div class="menu-pane-header">Pins</div><ul id="menu-pins-list"></ul></div><div class="menu-pane-header">Table of Contents</div><div id="menu-toc"><ol class="toc"><li><span class="item-toggle-none"></span><a href="#introduction" title="Introduction">Introduction</a></li><li><span class="item-toggle-none"></span><a href="#sec-asyncblockstart" title="AsyncBlockStart ( promiseCapability, asyncBody, asyncContext )"><span class="secnum">1</span> <ins>AsyncBlockStart ( <var>promiseCapability</var>, <var>asyncBody</var>, <var>asyncContext</var> )</ins></a></li><li><span class="item-toggle-none"></span><a href="#sec-innermoduleevaluation" title="InnerModuleEvaluation( module, stack, index )"><span class="secnum">2</span> InnerModuleEvaluation( <var>module</var>, <var>stack</var>, <var>index</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-moduleexecution" title="ModuleExecution( module )"><span class="secnum">3</span> ModuleExecution( <var>module</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-async-functions-abstract-operations-async-function-start" title="AsyncFunctionStart ( promiseCapability, asyncFunctionBody )"><span class="secnum">4</span> AsyncFunctionStart ( <var>promiseCapability</var>, <var>asyncFunctionBody</var> )</a></li></ol></div></div><div id="spec-container"><h1 class="version first">Stage 1 Draft / April 30, 2018</h1><h1 class="title">Top-Level Await</h1>
<script src="ecmarkup.js" defer=""></script>
<link rel="stylesheet" href="ecmarkup.css">

<emu-intro id="introduction">
  <h1>Introduction</h1>

    <p>Top-Level Await allows the <code>await</code> keyword to be used at the top level of the module goal.</p>
</emu-intro>

<emu-clause id="sec-asyncblockstart" aoid="AsyncBlockStart">
  <h1><span class="secnum">1</span><ins>AsyncBlockStart ( <var>promiseCapability</var>, <var>asyncBody</var>, <var>asyncContext</var> )</ins></h1>
  <emu-alg><ol><li>Let <var>runningContext</var> be the <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</li><li>Set the code evaluation state of <var>asyncContext</var> such that when evaluation is resumed for that <emu-xref href="#sec-execution-contexts"><a href="https://tc39.github.io/ecma262/#sec-execution-contexts">execution context</a></emu-xref> the following steps will be performed:<ol><li>Let <var>result</var> be the result of evaluating <var>asyncBody</var>.</li><li>Assert: If we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done.</li><li>Remove <var>asyncContext</var> from the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref> and restore the <emu-xref href="#sec-execution-contexts"><a href="https://tc39.github.io/ecma262/#sec-execution-contexts">execution context</a></emu-xref> that is at the top of the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref> as the <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</li><li>If <var>result</var>.[[Type]] is <emu-const>normal</emu-const>, then<ol><li>Perform !&nbsp;<emu-xref aoid="Call" id="_ref_0"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, «<emu-val>undefined</emu-val>»).</li></ol></li><li>Else if <var>result</var>.[[Type]] is <emu-const>return</emu-const>, then<ol><li>Perform !&nbsp;<emu-xref aoid="Call" id="_ref_1"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, «<var>result</var>.[[Value]]»).</li></ol></li><li>Else,<ol><li>Assert: <var>result</var>.[[Type]] is <emu-const>throw</emu-const>.</li><li>Perform !&nbsp;<emu-xref aoid="Call" id="_ref_2"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, «<var>result</var>.[[Value]]»).</li></ol></li><li>Return.</li></ol></li><li>Push <var>asyncContext</var> onto the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref>; <var>asyncContext</var> is now the <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</li><li>Resume the suspended evaluation of <var>asyncContext</var>. Let <var>result</var> be the value returned by the resumed computation.</li><li>Assert: When we return here, <var>asyncContext</var> has already been removed from the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref> and <var>runningContext</var> is the currently <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</li><li>Assert: <var>result</var> is a normal completion with a value of <emu-val>undefined</emu-val>. The possible sources of completion values are Await or, if the async function doesn't await anything, the step 2.g above.
  </li></ol></emu-alg>
</emu-clause>

<emu-clause id="sec-innermoduleevaluation" aoid="InnerModuleEvaluation">
  <h1><span class="secnum">2</span>InnerModuleEvaluation( <var>module</var>, <var>stack</var>, <var>index</var> )</h1>

  <p>The InnerModuleEvaluation abstract operation is used by Evaluate to perform the actual evaluation process for the <emu-xref href="#sec-source-text-module-records"><a href="https://tc39.github.io/ecma262/#sec-source-text-module-records">Source Text Module Record</a></emu-xref> <var>module</var>, as well as recursively on all other modules in the dependency graph. The <var>stack</var> and <var>index</var> parameters, as well as <var>module</var>'s [[DFSIndex]] and [[DFSAncestoreIndex]] fields, are used the same way as in InnerModuleInstantiation.</p>

  <p>This abstract operation performs the following steps:</p>

  <emu-alg><ol><li>If <var>module</var> is not a <emu-xref href="#sec-source-text-module-records"><a href="https://tc39.github.io/ecma262/#sec-source-text-module-records">Source Text Module Record</a></emu-xref>, then<ol><li>Perform ? <var>module</var>.Evaluate().</li><li>Return <var>index</var>.</li></ol></li><li>If <var>module</var>.[[Status]] is <code>"evaluated"</code>, then<ol><li>If <var>module</var>.[[EvaluationError]] is <emu-val>undefined</emu-val>, return <var>index</var>.</li><li>Otherwise return <var>module</var>.[[EvaluationError]].</li></ol></li><li>If <var>module</var>.[[Status]] is <code>"evaluating"</code>, return <var>index</var>.</li><li>Assert: <var>module</var>.[[Status]] is <code>"instantiated"</code>.</li><li>Set <var>module</var>.[[Status]] to <code>"evaluating"</code>.</li><li>Set <var>module</var>.[[DFSIndex]] to <var>index</var>.</li><li>Set <var>module</var>.[[DFSAncestorIndex]] to <var>index</var>.</li><li>Set <var>index</var> to <var>index</var> + 1.</li><li>Append <var>module</var> to <var>stack</var>.</li><li>For each String <var>required</var> that is an element of <var>module</var>.[[RequestedModules]], do<ol><li>Let <var>requiredModule</var> be !&nbsp;<emu-xref aoid="HostResolveImportedModule" id="_ref_3"><a href="https://tc39.github.io/ecma262/#sec-hostresolveimportedmodule">HostResolveImportedModule</a></emu-xref>(<var>module</var>, <var>required</var>).</li><li>NOTE: Instantiate must be completed successfully prior to invoking this method, so every requested module is guaranteed to resolve successfully.</li><li>Set <var>index</var> to ?&nbsp;<emu-xref aoid="InnerModuleEvaluation" id="_ref_4"><a href="#sec-innermoduleevaluation">InnerModuleEvaluation</a></emu-xref>(<var>requiredModule</var>, <var>stack</var>, <var>index</var>).</li><li>Assert: <var>requiredModule</var>.[[Status]] is either <code>"evaluating"</code> or <code>"evaluated"</code>.</li><li>Assert: <var>requiredModule</var>.[[Status]] is <code>"evaluating"</code> if and only if <var>requiredModule</var> is in <var>stack</var>.</li><li>If <var>requiredModule</var>.[[Status]] is <code>"evaluating"</code>, then<ol><li>Assert: <var>requiredModule</var> is a <emu-xref href="#sec-source-text-module-records"><a href="https://tc39.github.io/ecma262/#sec-source-text-module-records">Source Text Module Record</a></emu-xref>.</li><li>Set <var>module</var>.[[DFSAncestorIndex]] to <emu-xref aoid="min"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">min</a></emu-xref>(<var>module</var>.[[DFSAncestorIndex]], <var>requiredModule</var>.[[DFSAncestorIndex]]).</li></ol></li></ol></li><li>Perform ?&nbsp;<emu-xref aoid="ModuleExecution" id="_ref_5"><a href="#sec-moduleexecution">ModuleExecution</a></emu-xref>(<var>module</var>).</li><li>Assert: <var>module</var> occurs exactly once in <var>stack</var>.</li><li>Assert: <var>module</var>.[[DFSAncestorIndex]] is less than or equal to <var>module</var>.[[DFSIndex]].</li><li>If <var>module</var>.[[DFSAncestorIndex]] equals <var>module</var>.[[DFSIndex]], then<ol><li>Let <var>done</var> be <emu-val>false</emu-val>.</li><li>Repeat, while <var>done</var> is <emu-val>false</emu-val>,<ol><li>Let <var>requiredModule</var> be the last element in <var>stack</var>.</li><li>Remove the last element of <var>stack</var>.</li><li>Set <var>requiredModule</var>.[[Status]] to <code>"evaluated"</code>.</li><li>If <var>requiredModule</var> and <var>module</var> are the same <emu-xref href="#sec-abstract-module-records"><a href="https://tc39.github.io/ecma262/#sec-abstract-module-records">Module Record</a></emu-xref>, set <var>done</var> to <emu-val>true</emu-val>.</li></ol></li></ol></li><li>Return <var>index</var>.
  </li></ol></emu-alg>
</emu-clause>

<emu-clause id="sec-moduleexecution" aoid="ModuleExecution">
  <h1><span class="secnum">3</span>ModuleExecution( <var>module</var> )</h1>

  <p>The ModuleExecution abstract operation is used by <emu-xref aoid="InnerModuleEvaluation" id="_ref_6"><a href="#sec-innermoduleevaluation">InnerModuleEvaluation</a></emu-xref> to initialize the <emu-xref href="#sec-execution-contexts"><a href="https://tc39.github.io/ecma262/#sec-execution-contexts">execution context</a></emu-xref> of the module and evaluate the module's code within it.</p>

  <p>This abstract operation performs the following steps:</p>

  <emu-alg><ol><li>Let <var>moduleCxt</var> be a new ECMAScript code <emu-xref href="#sec-execution-contexts"><a href="https://tc39.github.io/ecma262/#sec-execution-contexts">execution context</a></emu-xref>.</li><li>Set the Function of <var>moduleCxt</var> to <emu-val>null</emu-val>.</li><li>Assert: <var>module</var>.[[Realm]] is not <emu-val>undefined</emu-val>.</li><li>Set the <emu-xref href="#realm"><a href="https://tc39.github.io/ecma262/#realm">Realm</a></emu-xref> of <var>moduleCxt</var> to <var>module</var>.[[Realm]].</li><li>Set the ScriptOrModule of <var>moduleCxt</var> to <var>module</var>.</li><li>Assert: <var>module</var> has been linked and declarations in its <emu-xref href="#module-environment"><a href="https://tc39.github.io/ecma262/#module-environment">module environment</a></emu-xref> have been instantiated.</li><li>Set the VariableEnvironment of <var>moduleCxt</var> to <var>module</var>.[[Environment]].</li><li>Set the LexicalEnvironment of <var>moduleCxt</var> to <var>module</var>.[[Environment]].</li><li><ins>Let <var>promiseCapability</var> be !&nbsp;<emu-xref aoid="NewPromiseCapability" id="_ref_7"><a href="https://tc39.github.io/ecma262/#sec-newpromisecapability">NewPromiseCapability</a></emu-xref>(<emu-xref href="#sec-promise-constructor"><a href="https://tc39.github.io/ecma262/#sec-promise-constructor">%Promise%</a></emu-xref>).</ins></li><li>Suspend the currently <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</li><li><ins>Perform !&nbsp;<emu-xref aoid="AsyncBlockStart" id="_ref_8"><a href="#sec-asyncblockstart">AsyncBlockStart</a></emu-xref>(<var>promiseCapability</var>, <var>module</var>.[[ECMAScriptCode]], <var>moduleCxt</var>).</ins></li><li><del>Push <var>moduleCxt</var> on to the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref>; <var>moduleCxt</var> is now the <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</del></li><li><del>Let <var>result</var> be the result of evaluating <var>module</var>.[[ECMAScriptCode]].</del></li><li><del>Suspend <var>moduleCxt</var> and remove it from the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref>.</del></li><li>Resume the context that is now on the top of the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref> as the <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</li><li><del>Return <emu-xref aoid="Completion" id="_ref_9"><a href="https://tc39.github.io/ecma262/#sec-completion-record-specification-type">Completion</a></emu-xref>(<var>result</var>).</del></li><li><ins>Return <var>promiseCapability</var>.[[Promise]].</ins>
  </li></ol></emu-alg>
</emu-clause>


<emu-clause id="sec-async-functions-abstract-operations-async-function-start" aoid="AsyncFunctionStart">
  <h1><span class="secnum">4</span>AsyncFunctionStart ( <var>promiseCapability</var>, <var>asyncFunctionBody</var> )</h1>
  <emu-alg><ol><li>Let <var>runningContext</var> be the <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</li><li>Let <var>asyncContext</var> be a copy of <var>runningContext</var>.</li><li><ins>Perform !&nbsp;<emu-xref aoid="AsyncBlockStart" id="_ref_10"><a href="#sec-asyncblockstart">AsyncBlockStart</a></emu-xref>(<var>promiseCapability</var>, <var>asyncFunctionBody</var>, <var>asyncContext</var>).</ins></li><li><del>Set the code evaluation state of <var>asyncContext</var> such that when evaluation is resumed for that <emu-xref href="#sec-execution-contexts"><a href="https://tc39.github.io/ecma262/#sec-execution-contexts">execution context</a></emu-xref> the following steps will be performed:</del><ol><li><del>Let <var>result</var> be the result of evaluating <var>asyncFunctionBody</var>.</del></li><li><del>Assert: If we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done.</del></li><li><del>Remove <var>asyncContext</var> from the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref> and restore the <emu-xref href="#sec-execution-contexts"><a href="https://tc39.github.io/ecma262/#sec-execution-contexts">execution context</a></emu-xref> that is at the top of the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref> as the <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</del></li><li><del>If <var>result</var>.[[Type]] is <emu-const>normal</emu-const>, then</del><ol><li><del>Perform !&nbsp;<emu-xref aoid="Call" id="_ref_11"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, «<emu-val>undefined</emu-val>»).</del></li></ol></li><li><del>Else if <var>result</var>.[[Type]] is <emu-const>return</emu-const>, then</del><ol><li><del>Perform !&nbsp;<emu-xref aoid="Call" id="_ref_12"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, «<var>result</var>.[[Value]]»).</del></li></ol></li><li><del>Else,</del><ol><li><del>Assert: <var>result</var>.[[Type]] is <emu-const>throw</emu-const>.</del></li><li><del>Perform !&nbsp;<emu-xref aoid="Call" id="_ref_13"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, «<var>result</var>.[[Value]]»).</del></li></ol></li><li><del>Return.</del></li></ol></li><li><del>Push <var>asyncContext</var> onto the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref>; <var>asyncContext</var> is now the <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</del></li><li><del>Resume the suspended evaluation of <var>asyncContext</var>. Let <var>result</var> be the value returned by the resumed computation.</del></li><li><del>Assert: When we return here, <var>asyncContext</var> has already been removed from the <emu-xref href="#execution-context-stack"><a href="https://tc39.github.io/ecma262/#execution-context-stack">execution context stack</a></emu-xref> and <var>runningContext</var> is the currently <emu-xref href="#running-execution-context"><a href="https://tc39.github.io/ecma262/#running-execution-context">running execution context</a></emu-xref>.</del></li><li><del>Assert: <var>result</var> is a normal completion with a value of <emu-val>undefined</emu-val>. The possible sources of completion values are Await or, if the async function doesn't await anything, the step 3.g above.</del></li><li>Return.
  </li></ol></emu-alg>
</emu-clause>
</div></body>